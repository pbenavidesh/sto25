---
title: "estacionariedad"
format: 
  html:
    embed-resources: true
    toc: true
---

```{r}
#| message: false

library(tidyverse)
library(fpp3)
library(patchwork)
```

```{r}
aus_production |> 
  autoplot(Cement)

aus_production |> 
  autoplot(log(Cement))

lambda <- aus_production |> 
  features(Cement, guerrero) |> 
  pull(lambda_guerrero)

aus_production |> 
  autoplot(box_cox(Cement, lambda))

aus_production |> 
  autoplot(box_cox(Cement, lambda))
```

```{r}
#| warning: false

aus_production |> 
  autoplot(box_cox(Cement, lambda) |> difference(lag = 4, differences = 1))

aus_production |> 
  autoplot(box_cox(Cement, lambda) |> difference(lag = 4, differences = 2))

aus_production |> 
  autoplot(box_cox(Cement, lambda) |> difference(lag = 4) |> difference())

aus_production |> 
  autoplot(box_cox(Cement, lambda) |> difference())
```



```{r}
aus_production |> 
  features(box_cox(Cement, lambda), unitroot_kpss)
```



Parece que logramos estabilizar la varianza con logaritmos. Falta estabilizar la media. Vamos a aplicar diferencias estacionales:

```{r}
#| warning: false

aus_production |> 
  autoplot(
    Cement |> log() |> difference(lag = 4)
  )
```

Vamos a comprobar si esta serie ya es estacionaria o no:

```{r}
aus_production |> 
  features(box_cox(Cement, lambda) |> difference(lag = 4), unitroot_kpss)
```

```{r}
aus_production |> 
  features(box_cox(Cement, lambda), unitroot_nsdiffs)
```

La prueba `unitroot_nsdiffs` dice que se deben aplicar **diferencias estacionales** una vez para convertirla en estacionaria. Vamos a ver si, adicionalmente, se deben aplicar diferencias no estacionales:

```{r}
aus_production |> 
  features(log(Cement) |> difference(4), unitroot_ndiffs)
```

```{r}
aus_production |> 
  features(log(Cement), unitroot_ndiffs)
```

```{r}
#| warning: false
aus_production |> 
  autoplot(log(Cement) |> difference())

aus_production |> 
  features(log(Cement) |> difference(), unitroot_kpss)
```
# ARIMA

```{r}
cemento_desestacionalizado <- aus_production |> 
  model(stl = STL(log(Cement), robust = TRUE)) |> 
  components() |> 
  select(Quarter, season_adjust) |> 
  rename(Cement = season_adjust)

cemento_desestacionalizado |> 
  autoplot(Cement)

cemento_desestacionalizado |> 
  autoplot(log(Cement))
```
Vamos a modelar el cemento desestacionalizado usando ARIMA. La serie parece no ser estacionaria.

```{r}
cemento_desestacionalizado |>
  features(Cement, unitroot_ndiffs)
```

La prueba me indica que necesitamos una diferencia no estacional. En otras palabras, sugiere que el orden `d` del modelo ARIMA debe ser 1 (`d=1`).

Vamos a obtener los órdenes `p` y `q` observando las gráficas de la función de autocorrelación **ACF** y de la función de autocorrelación parcial **PACF**:

```{r}
cemento_desestacionalizado |> 
  gg_tsdisplay(Cement, plot_type = 'partial')
```

Graficar la ACF y PACF de una serie que **no** es estacionaria no me sirve de nada. Vamos a graficar la serie en primeras diferencias:

```{r}
#| warning: false

cemento_desestacionalizado |> 
  gg_tsdisplay(Cement |> difference(), plot_type = 'partial')
```

De acuerdo a la teoría y lo que alcanzamos a ver en la **ACF** y **PACF**, el modelo ARIMA a estimar sería un `ARIMA(2,1,2)`.

```{r}
cemento_fit <- cemento_desestacionalizado |> 
  model(
    arima_212 = ARIMA(Cement ~ pdq(2,1,2) + PDQ(0,0,0)),
    arima_212_log = ARIMA(log(Cement) ~ pdq(2,1,2) + PDQ(0,0,0)),
    arima_211 = ARIMA(Cement ~ pdq(2,2,1) + PDQ(0,0,0)),
    arima_312 = ARIMA(Cement ~ pdq(3,1,2) + PDQ(0,0,0)),
    arima_213 = ARIMA(Cement ~ pdq(2,1,3) + PDQ(0,0,0)),
    arima_415 = ARIMA(Cement ~ pdq(4,1,5) + PDQ(0,0,0))
  )

cemento_fit

cemento_fit |> 
  select(arima_212) |>
  report()

cemento_fit |> 
  select(arima_211) |>
  report()

cemento_fit |> glance() |> 
  arrange(AICc)

cemento_fit |> 
  accuracy()
```
```{r}
#| warning: false

cemento_desestacionalizado |> 
  autoplot(Cement)

cemento_desestacionalizado |> 
  autoplot(Cement |> difference())

cemento_desestacionalizado |> 
  autoplot(Cement |> difference(differences = 2))
```

# Ejercicio

## PIB de México

```{r}
mex <- global_economy |>
  filter(Country == "Mexico") 

mex |>
  autoplot(GDP)
```

```{r}
mex_lambda <- mex |> 
  features(GDP, guerrero) |> 
  pull(lambda_guerrero)

p1 <- mex |>
  autoplot(GDP) +
  ggtitle("Serie en niveles")

p2 <- mex |> 
  autoplot(log(GDP)) +
  ggtitle("Serie en logaritmos")

p3 <- mex |> 
  autoplot(box_cox(GDP, mex_lambda)) +
  ggtitle("Serie con Box-Cox")

p1|p2|p3
```
```{r}
mex |> 
  mutate(
    log_gdp = log(GDP),
    bc_gdp = box_cox(GDP, mex_lambda)
  ) |> 
  pivot_longer(c(GDP, log_gdp, bc_gdp)) |>
  features(value, unitroot_ndiffs)

```

```{r}
mex_fit <- mex |> 
  model(
    mafer     = ARIMA(box_cox(GDP, mex_lambda) ~ pdq(2,1,2) + PDQ(0,0,0)),
    mateo     = ARIMA(box_cox(GDP, mex_lambda) ~ pdq(2,1,1) + PDQ(0,0,0)),
    ana_luisa = ARIMA(log(GDP) ~ pdq(2,1,0) + PDQ(0,0,0)),
    hector    = ARIMA(GDP ~ pdq(1,1,1) + PDQ(0,0,0)),
    arturo    = ARIMA(box_cox(GDP, mex_lambda) ~ pdq(1,2,1) + PDQ(0,0,0)),
    pablo     = ARIMA(box_cox(GDP, mex_lambda) ~ PDQ(0,0,0)),
    ets       = ETS(box_cox(GDP, mex_lambda)),
    semi      = ARIMA(box_cox(GDP, mex_lambda) ~ pdq(p = 0:3, d = 1) + PDQ(0,0,0))
  )


mex_fit |> 
  select(pablo) |> 
  report()

mex_fit

mex_fit |> 
  glance() |> 
  arrange(AICc)

mex_fit |> 
  accuracy() |>
  select(.model, RMSE, MAE, MAPE) |>
  arrange(MAPE)
```

```{r}
tictoc::tic()
mex |> 
  model(
    mafer = ARIMA(box_cox(GDP, mex_lambda) ~ pdq(2,1,2) + PDQ(0,0,0))
  )
tictoc::toc()

tictoc::tic()
mex |> 
  model(
    auto_arima = ARIMA(box_cox(GDP, mex_lambda) ~ PDQ(0,0,0))
  )
tictoc::toc()

tictoc::tic()
mex |> 
  model(
    auto_arima = ARIMA(box_cox(GDP, mex_lambda) ~ PDQ(0,0,0), stepwise = FALSE, approximation = FALSE)
  )
tictoc::toc()
```



## PIB de Noruega

```{r}
noruega <- global_economy |>
  filter(Country == "Norway") 

noruega |>
  autoplot(GDP)
```





```{r}
noruega |> 
  model(
    arima = ARIMA(GDP ~ pdq(1,2,1))
  ) |> 
  report()
```



# SARIMA

```{r}
h02 <- PBS |> 
  filter(ATC2 == "H02")  |> 
  summarise(Cost = sum(Cost)/1e6)

h02_train <- h02 |> 
  filter_index(. ~ "2004 Jun.")

h02 |> 
  autoplot(Cost)

h02 |> 
  autoplot(log(Cost))
```
```{r}
h02 |> 
  features(log(Cost), unitroot_nsdiffs)
```
Aplicando 1 vez las diferencias estacionales:

```{r}
#| warning: false

h02 |> 
  autoplot(log(Cost) |> difference(lag = 12))
```

```{r}
h02 |> 
  features(log(Cost) |> difference(lag = 12), unitroot_ndiffs)
```

```{r}
#| warning: false

h02 |> 
  gg_tsdisplay(log(Cost), plot_type = 'partial', lag_max = 48)

h02 |> 
  gg_tsdisplay(log(Cost) |> difference(lag = 12) |> difference(), plot_type = 'partial', lag_max = 48)

h02 |> 
  gg_tsdisplay(log(Cost) |> difference(lag = 12), plot_type = 'partial', lag_max = 48)
```

## Ejercicio

Pronóstico a 4 años utilizando SARIMA. Se busca el menor MAPE de pronóstico.

