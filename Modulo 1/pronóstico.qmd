---
title: "pronóstico"
format: html
---

```{r}
library(tidyverse)
library(fpp3)
```

```{r}
gas_train <- aus_production |> 
  filter_index(. ~ "2007 Q2")

gas_train
```

```{r}
gas_train |> 
  autoplot(Gas)
gas_train |> 
  autoplot(log(Gas))
```
Logaritmos no logra estabilizar la varianza. Vamos a probar con Box-Cox

```{r}
gas_lambda <- gas_train |> 
  features(Gas, features = guerrero) |> 
  pull()
gas_lambda
```
```{r}
gas_train |> 
  autoplot(box_cox(Gas, lambda = gas_lambda))
```

¿Qué método de pronóstico se ajustaría mejor a esta serie?

```{r}
gas_fit <- gas_train |> 
  model(
    drift = RW(box_cox(Gas, gas_lambda) ~ drift()),
    snaive = SNAIVE(box_cox(Gas, gas_lambda)),
    media = MEAN(box_cox(Gas, gas_lambda))
  )

gas_fit
```

Vamos a hacer un **diagnóstico de los residuos** de los modelos. La función `augment()` nos permite obtener los residuos y otros valores ajustados de los modelos.

```{r}
gas_aug <- gas_fit |> 
  augment()
gas_aug
```
Gráfica de los residuos de los modelos:
```{r}
#| warning: false

gas_aug |> 
  autoplot(.innov) +
  facet_wrap(~.model, ncol = 1, scales = "free_y")
```
Gráfica de la ACF del residuo de los modelos:
```{r}
gas_aug |> 
  ACF(.innov) |>
  autoplot() +
  facet_wrap(~.model, ncol = 1, scale = "free_y")
```
Gráfica del histograma de los residuos de los modelos:
```{r}
#| warning: false

gas_aug |> 
  ggplot(aes(x = .innov, fill = .model)) +
  geom_histogram() +
  facet_wrap(~.model, ncol = 1, scales = "free_y")
```
Función para obtener el diagnóstico de residuos completo de un solo modelo:
```{r}
#| warning: false

gas_fit |> 
  select(drift) |> 
  gg_tsresiduals()+
  ggtitle("Diagnóstico de residuos para el modelo del Drift")
```
Vamos a hacer pronóstico con estos tres modelos:

```{r}
gas_fc <- gas_fit |> 
  forecast(h = "3 years")

gas_fc
```

```{r}
aus_prod_recent <- aus_production |> 
  filter_index("2003 Q1" ~ .)
```


```{r}
gas_fc |> 
  autoplot(aus_prod_recent) +
  facet_wrap(vars(.model), scale = "free_y", ncol = 1)
```
```{r}
gas_fc |> 
  accuracy(aus_production) |> 
  arrange(RMSE)
```

Esto mismo lo podríamos calcular para los residuos (en el train):

```{r}
gas_fit |> 
  accuracy() |> 
  arrange(RMSE)
```

# Pronóstico con descomposición

```{r}
gas_stl <- gas_train |> 
  model(
    stl = STL(box_cox(Gas, gas_lambda) ~ season(window = "periodic"), robust = TRUE)
  ) |> 
  components()

gas_stl

gas_stl |> 
  autoplot()

gas_stl |> 
  ggplot(aes(x = Quarter, y = season_year)) +
  geom_line() +
  ggtitle("Componente estacional de la producción de gas")

gas_stl |> 
  ggplot(aes(x = Quarter, y = season_adjust)) +
  geom_line() +
  ggtitle("Serie desestacionalizada de la producción de gas")
```




```{r}
gas_dcmp <- gas_train |> 
  model(
    dcmp = decomposition_model(                                                   #<1>
      STL(box_cox(Gas, gas_lambda) ~ season(window = "periodic"), robust = TRUE), #<2>
      RW(season_adjust ~ drift()),                                                #<3>
      SNAIVE(season_year)                                                         #<4>
    )
  )

gas_dcmp
```

1. `decomposition_model()` define que se realizará un pronóstico a partir de una descomposición.
2. Primero se define cómo se realizará la descomposición. En este caso, con STL, con ajuste robusto y con componente estacional periódica.
3. Luego se define el modelo para la serie desestacionalizada, `season_adjust`.
4. Finalmente, se define el modelo para la serie estacional, `season_year`. Si este componente no se especifica, R va a utilizar `SNAIVE()` por default.

```{r}
#| warning: false
gas_dcmp |> 
  gg_tsresiduals()
```
```{r}
gas_dcmp |> 
  augment() |> 
  features(.innov, ljung_box, lag = 8)

gas_dcmp |> 
  accuracy()
```

```{r}
gas_dcmp_fc <- gas_dcmp |> 
  forecast(h = "3 years")

gas_dcmp_fc 

gas_dcmp_fc |> 
  autoplot(aus_prod_recent)
```
```{r}
gas_fc_full <- gas_fc |> 
  full_join(gas_dcmp_fc)

gas_fc_full
```

```{r}
gas_fc_full |> 
  accuracy(aus_production) |> 
  arrange(RMSE)

gas_fc_full |> 
  autoplot(aus_prod_recent, level = NULL)
```
```{r}
gas_fit_full <- gas_fit |> 
  cross_join(gas_dcmp) |> 
  mutate(combinado = (snaive + dcmp)/2)

gas_fit_full
```

```{r}
gas_fcst_full <- gas_fit_full |> 
  forecast(h = "3 years")

gas_fcst_full |>
  filter(.model %in% c("dcmp", "combinado", "snaive")) |> 
  autoplot(aus_prod_recent, level = NULL)

gas_fcst_full |>
  accuracy(aus_production) |> 
  arrange(RMSE)
```

# ETS
## SES

```{r}
ses <- gas_train |> 
  model(
    ses = ETS(Gas ~                 #<1>
                error("A") +        #<2>
                trend("N") +        #<3>
                season("N"))        #<3>
  )

ses
```

1. `ETS()` es la función para estimar modelos de suavización exponencial y se deben definir 3 argumentos: error, tendencia y estacionalidad.
2. Tenemos dos opciones: `"A"` para error aditivo, y `M` para multiplicativo.
3. Para especificar que no queremos tendencia ni estacionalidad, ponemos `"N"` en ambos casos.

```{r}
report(ses)
```

